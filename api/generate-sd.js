import Replicate from 'replicate';
import { GoogleGenerativeAI } from '@google/generative-ai';

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN
});

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Toggle between Gemini native image generation vs SDXL
const USE_GEMINI_IMAGE_GEN = true; // Set to false to use SDXL instead

// Helper function to convert base64 data URL to buffer for Gemini
function base64ToBuffer(base64Data) {
  const base64String = base64Data.replace(/^data:image\/\w+;base64,/, '');
  return Buffer.from(base64String, 'base64');
}

// Helper function to get mime type from base64 data URL
function getMimeType(base64Data) {
  const match = base64Data.match(/^data:(image\/\w+);base64,/);
  return match ? match[1] : 'image/png';
}

export default async function handler(req, res) {
  // Allow all origins (CORS)
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  res.setHeader('Access-Control-Allow-Credentials', 'true');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { prompt, image } = req.body;
    
    if (!prompt || prompt.length < 3) {
      return res.status(400).json({ error: 'Please provide a detailed prompt' });
    }

    // OPTION 1: Image editing with Gemini native image generation
    if (image && USE_GEMINI_IMAGE_GEN) {
      console.log('Using Gemini native image generation (Imagen 3):', prompt);
      
      try {
        // Use Gemini 2.0 Flash with image generation capabilities
        const model = genAI.getGenerativeModel({ 
          model: "gemini-2.0-flash-exp"
        });
        
        // Prepare the image data for Gemini
        const imageBuffer = base64ToBuffer(image);
        const mimeType = getMimeType(image);
        
        const imagePart = {
          inlineData: {
            data: imageBuffer.toString('base64'),
            mimeType: mimeType
          }
        };
        
        // Create content with image and text prompt
        const parts = [
          {
            text: `Based on this image, ${prompt}. Generate a new image that incorporates these changes while preserving the original style and composition.`
          },
          imagePart
        ];
        
        // Generate with native image generation
        const result = await model.generateContent({
          contents: [{ role: 'user', parts }],
          generationConfig: {
            responseModalities: ['IMAGE'],  // Request image output
            temperature: 0.4,
            topK: 32,
            topP: 1,
          }
        });
        
        const response = await result.response;
        
        // Extract generated image from response
        // Gemini returns images in the parts array
        const generatedImage = response.candidates[0]?.content?.parts?.find(
          part => part.inlineData
        );
        
        if (!generatedImage) {
          throw new Error('No image generated by Gemini');
        }
        
        // Convert to base64 data URL
        const base64Image = `data:${generatedImage.inlineData.mimeType};base64,${generatedImage.inlineData.data}`;
        
        res.status(200).json({
          success: true,
          imageUrl: base64Image,
          prompt: prompt,
          model: 'gemini-2.0-flash-imagen'
        });
        
      } catch (geminiError) {
        console.error('Gemini image generation error:', geminiError);
        
        // Fallback to Gemini Vision + SDXL if native generation fails
        console.log('Falling back to Gemini Vision + SDXL');
        return await generateWithVisionAndSDXL(req.body, res);
      }
    }
    
    // OPTION 2: Image editing with Gemini Vision analysis + SDXL generation
    else if (image && !USE_GEMINI_IMAGE_GEN) {
      return await generateWithVisionAndSDXL(req.body, res);
    }
    
    // OPTION 3: Text-only generation
    else {
      console.log('Text-only generation');
      
      if (USE_GEMINI_IMAGE_GEN) {
        // Use Gemini native image generation for text-only
        return await generateWithGeminiOnly(prompt, res);
      } else {
        // Use SDXL for text-only
        return await generateWithSDXL(prompt, res);
      }
    }

  } catch (error) {
    console.error('Generation error:', error);
    
    if (error.message && error.message.includes('safety')) {
      return res.status(400).json({
        error: 'Invalid prompt. Please try a different description.'
      });
    }
    
    if (error.message && error.message.includes('SAFETY')) {
      return res.status(400).json({
        error: 'Content safety filter triggered. Please try a different prompt or image.'
      });
    }
    
    if (error.message && error.message.includes('image')) {
      return res.status(400).json({
        error: 'Invalid image format. Please try a different image.'
      });
    }

    res.status(500).json({
      error: 'Failed to generate design. Please try again.'
    });
  }
}

// Helper function: Gemini Vision + SDXL
async function generateWithVisionAndSDXL(body, res) {
  const { prompt, image } = body;
  
  console.log('Using Gemini Vision + SDXL:', prompt);
  
  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
  
  const imageBuffer = base64ToBuffer(image);
  const mimeType = getMimeType(image);
  
  const imagePart = {
    inlineData: {
      data: imageBuffer.toString('base64'),
      mimeType: mimeType
    }
  };
  
  const visionPrompt = `Analyze this image carefully and create a detailed image generation prompt that:
1) Preserves the original style, colors, composition, and key visual elements
2) Incorporates this modification: "${prompt}"
3) Is optimized for image generation AI models

Provide only the enhanced prompt text, no explanations or additional text.`;
  
  const visionResult = await model.generateContent([visionPrompt, imagePart]);
  const visionResponse = await visionResult.response;
  const optimizedPrompt = visionResponse.text().trim();
  
  console.log('Gemini-enhanced prompt:', optimizedPrompt);
  
  const inputConfig = {
    prompt: `${optimizedPrompt}, high quality, detailed, vibrant artwork, professional design`,
    negative_prompt: "ugly, blurry, low quality, distorted, text, watermark, deformed",
    width: 1024,
    height: 1024,
    num_outputs: 1,
    num_inference_steps: 40,
    guidance_scale: 7.5
  };
  
  const output = await replicate.run(
    "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    { input: inputConfig }
  );

  const imageUrl = output[0];
  
  const imageResponse = await fetch(imageUrl);
  const resultBuffer = await imageResponse.arrayBuffer();
  const base64Image = `data:image/png;base64,${Buffer.from(resultBuffer).toString('base64')}`;
  
  return res.status(200).json({
    success: true,
    imageUrl: base64Image,
    prompt: prompt,
    enhancedPrompt: optimizedPrompt,
    model: 'gemini-vision-sdxl'
  });
}

// Helper function: Gemini native image generation (text-only)
async function generateWithGeminiOnly(prompt, res) {
  console.log('Using Gemini native image generation (text-only):', prompt);
  
  const model = genAI.getGenerativeModel({ 
    model: "gemini-2.0-flash-exp"
  });
  
  const result = await model.generateContent({
    contents: [{
      role: 'user',
      parts: [{ 
        text: `Create a high-quality image: ${prompt}. Professional t-shirt design style, vibrant colors, detailed artwork.`
      }]
    }],
    generationConfig: {
      responseModalities: ['IMAGE'],
      temperature: 0.4,
      topK: 32,
      topP: 1,
    }
  });
  
  const response = await result.response;
  const generatedImage = response.candidates[0]?.content?.parts?.find(
    part => part.inlineData
  );
  
  if (!generatedImage) {
    throw new Error('No image generated by Gemini');
  }
  
  const base64Image = `data:${generatedImage.inlineData.mimeType};base64,${generatedImage.inlineData.data}`;
  
  return res.status(200).json({
    success: true,
    imageUrl: base64Image,
    prompt: prompt,
    model: 'gemini-2.0-flash-imagen'
  });
}

// Helper function: SDXL only (text-only)
async function generateWithSDXL(prompt, res) {
  console.log('Generating with Stable Diffusion XL (text-only):', prompt);
  
  const inputConfig = {
    prompt: `${prompt}, high quality, detailed, vibrant artwork, professional t-shirt design`,
    negative_prompt: "ugly, blurry, low quality, distorted, text, watermark",
    width: 1024,
    height: 1024,
    num_outputs: 1,
    num_inference_steps: 30,
    guidance_scale: 7.5
  };
  
  const output = await replicate.run(
    "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
    { input: inputConfig }
  );

  const imageUrl = output[0];

  return res.status(200).json({
    success: true,
    imageUrl: imageUrl,
    prompt: prompt,
    model: 'stable-diffusion-xl'
  });
}
