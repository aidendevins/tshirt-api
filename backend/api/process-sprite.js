import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';

dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Helper function to convert base64 data URL to buffer for Gemini
function base64ToBuffer(base64Data) {
  const base64String = base64Data.replace(/^data:image\/\w+;base64,/, '');
  return Buffer.from(base64String, 'base64');
}

// Helper function to get mime type from base64 data URL
function getMimeType(base64Data) {
  const match = base64Data.match(/^data:(image\/\w+);base64,/);
  return match ? match[1] : 'image/png';
}

// Helper function to convert buffer to base64 data URL
function bufferToDataUrl(buffer, mimeType) {
  const base64 = buffer.toString('base64');
  return `data:${mimeType};base64,${base64}`;
}

export default async function handler(req, res) {
  // CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  res.setHeader('Access-Control-Allow-Credentials', 'true');

  if (req.method === 'OPTIONS') return res.status(200).end();
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  try {
    const { imageData } = req.body || {};

    if (!imageData || !/^data:image\/\w+;base64,/.test(imageData)) {
      return res.status(400).json({ error: 'imageData (base64 data URL) is required' });
    }

    // Use Gemini to identify the main object and edit the image to have a green background
    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash-image' });
    const imageBuffer = base64ToBuffer(imageData);
    const mimeType = getMimeType(imageData);

    const prompt = `Identify the main object or subject in this image. Keep the main object exactly as it is, preserving all its details, colors, and features. Change the entire background to the exact color #00ff00. The background should be a solid #00ff00 color with no other elements. IMPORTANT: Do not add any other elements or text to the image.`;

    let editedImageDataUrl = null;
    
    try {
      // Use Gemini to edit the image - identify main object and set background to green
      const result = await model.generateContent({
        contents: [{
          role: 'user',
          parts: [
            { text: prompt },
            {
              inlineData: {
                data: imageBuffer.toString('base64'),
                mimeType: mimeType
              }
            }
          ]
        }],
        generationConfig: {
          responseModalities: ['IMAGE'],
          temperature: 0.4,
          topK: 32,
          topP: 1,
        }
      });

      const response = result.response;
      const generatedImage = response.candidates[0]?.content?.parts?.find(
        part => part.inlineData
      );

      if (!generatedImage || !generatedImage.inlineData) {
        throw new Error('No image generated by Gemini');
      }

      // Convert the generated image to base64 data URL
      editedImageDataUrl = `data:${generatedImage.inlineData.mimeType};base64,${generatedImage.inlineData.data}`;
      console.log('Gemini successfully edited image with green background');
      // return res.status(200).json({
      //   success: true,
      //   spriteImageUrl: editedImageDataUrl
      // });

      // Use the Gemini-edited image (with green background) for Python processing
      // Python will remove the green background to create a transparent sprite
      
    } catch (geminiError) {
      console.error('Gemini image editing error:', geminiError);
      return res.status(500).json({ 
        success: false,
        error: 'Failed to edit image with Gemini: ' + (geminiError.message || 'Unknown error')
      });
    }

    // Step 2: Use rembg CLI to remove green background from Gemini-edited image
    const { spawn } = await import('child_process');
    const fs = await import('fs/promises');
    const os = await import('os');
    const { join } = await import('path');

    const tmpDir = os.tmpdir();
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).slice(2);
    const inputImagePath = join(tmpDir, `process_sprite_input_${timestamp}_${randomId}.png`);
    const outputImagePath = join(tmpDir, `process_sprite_output_${timestamp}_${randomId}.png`);

    try {
      // Convert Gemini-edited image to buffer and save to temp file
      const imageDataToProcess = editedImageDataUrl || imageData;
      console.log('[JS] Preparing to process Gemini-edited image with rembg CLI...');
      console.log('[JS] Edited image data URL length:', editedImageDataUrl?.length || 0);
      
      const imageBuffer = base64ToBuffer(imageDataToProcess);
      await fs.writeFile(inputImagePath, imageBuffer);
      console.log('[JS] Wrote input image to temp file:', inputImagePath);

      // Call rembg CLI: rembg i input.png output.png
      // This is the exact same command that works perfectly when run manually
      const rembgCommand = 'rembg';
      const rembgArgs = ['i', inputImagePath, outputImagePath];
      
      console.log('[JS] Running rembg command:', rembgCommand, rembgArgs.join(' '));

      const rembgProcess = spawn(rembgCommand, rembgArgs, {
        stdio: ['ignore', 'pipe', 'pipe'],
        timeout: 60000 // 60 second timeout (rembg may need time to download models on first run)
      });

      console.log('[JS] Spawned rembg process. PID:', rembgProcess.pid);

      let stdout = '';
      let stderr = '';

      rembgProcess.stdout.on('data', (d) => {
        const data = d.toString();
        stdout += data;
        console.log('[JS] rembg stdout:', data.trim());
      });

      rembgProcess.stderr.on('data', (d) => {
        const data = d.toString();
        stderr += data;
        console.log('[JS] rembg stderr:', data.trim());
      });

      // Wait for process to complete
      const exitCode = await new Promise((resolve, reject) => {
        rembgProcess.on('close', (code) => {
          console.log('[JS] rembg process closed with code:', code);
          resolve(code);
        });
        rembgProcess.on('error', (err) => {
          console.error('[JS] rembg spawn error:', err);
          reject(err);
        });
      });

      // Clean up input file
      await fs.unlink(inputImagePath).catch(console.error);

      if (exitCode !== 0) {
        // Clean up output file if it exists
        await fs.unlink(outputImagePath).catch(() => {});
        console.error('[JS] rembg error. Exit code:', exitCode);
        console.error('[JS] rembg stderr:', stderr);
        return res.status(500).json({ 
          success: false,
          error: 'Background removal failed',
          details: stderr || 'Unknown error'
        });
      }

      // Check if output file exists
      try {
        await fs.access(outputImagePath);
      } catch (accessError) {
        console.error('[JS] Output file does not exist:', outputImagePath);
        return res.status(500).json({ 
          success: false,
          error: 'rembg did not create output file',
          details: stderr
        });
      }

      // Read the output PNG file
      console.log('[JS] Reading output image from:', outputImagePath);
      const outputImageBuffer = await fs.readFile(outputImagePath);
      
      // Clean up output file
      await fs.unlink(outputImagePath).catch(console.error);

      // Convert to base64 data URL
      const spriteImageUrl = bufferToDataUrl(outputImageBuffer, 'image/png');
      
      console.log('[JS] Successfully processed sprite. Image size:', outputImageBuffer.length, 'bytes');
      return res.status(200).json({
        success: true,
        spriteImageUrl: spriteImageUrl
      });

    } catch (error) {
      // Clean up temp files on error
      await fs.unlink(inputImagePath).catch(() => {});
      await fs.unlink(outputImagePath).catch(() => {});
      console.error('[JS] process-sprite error:', error);
      return res.status(500).json({ 
        success: false,
        error: 'Failed to process sprite',
        details: error.message
      });
    }

  } catch (err) {
    console.error('process-sprite error:', err);
    return res.status(500).json({ 
      success: false,
      error: 'Failed to process sprite' 
    });
  }
}

